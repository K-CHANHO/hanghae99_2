# 도메인별 DB 분리 환경에서의 트랜잭션 처리 설계

## 1. 배경
서비스가 확장됨에 따라 모놀리식 구조에서 MSA로 전환 시, 도메인별로 어플리케이션 서버와 DB를 분리하게 된다.  
이때 기존 단일 DB 트랜잭션 기반으로 처리하던 방식은 더 이상 도메인간 데이터 정합성을 보장할 수 없게 된다.

---

## 2. 트랜잭션 처리의 한계

| 구분      | 기존 단일 DB | 도메인별 DB 분리                |
|---------|--------------|---------------------------|
| 트랜잭션 범위 | 전체 서비스 | 각 도메인(DB) 단위              |
| ACID 보장 | 완전 보장 | 단일 DB 내에서만 보장             |
| 분산 트랜잭션 | 필요 없음 | 필요                        |
| 오류 시 처리 | 롤백 가능 | 다른 DB에 영향 없음 → 데이터 불일치 가능 |

### 문제점
1. **분산 트랜잭션의 부재**
    - 여러 DB를 한번에 제어하는 트랜잭션이 없으므로, 한 도메인의 작업 실패한다 해도 다른 도메인의 작업은 커밋됨
2. **데이터 정합성 보장 어려움**
    - 주문, 결제, 재고 등 복수 도메인 연계 로직에서 일관성 유지가 어려움

---

## 3. 대응 방안

### 3.1 이벤트 기반 처리
- 각 도메인은 **자기 트랜잭션 내에서 DB 처리 후 이벤트 발행**
- 이벤트 소비자는 **독립 트랜잭션**에서 처리
- 예: 주문 생성 → `OrderCreatedEvent` 발행 → 재고 서비스, 쿠폰 서비스가 구독

**장점**
- 도메인 간 느슨한 결합
- 트랜잭션 충돌 최소화

**단점**
- 이벤트 처리 순서 복잡성 증가
- 실패 시 보상 로직 필요

---

### 3.2 Saga 패턴
#### 3.2.1 Choreography
- 이벤트 기반 연쇄 처리
- 각 서비스가 자체 트랜잭션에서 이벤트 발행 → 다음 서비스가 구독
- 보상 트랜잭션으로 실패 처리

#### 3.2.2 Orchestration
- 중앙 **Saga Orchestrator**가 각 서비스 호출 및 상태 관리
- 단계별 성공/실패 판단 후 보상 수행

**장점**
- 분산 트랜잭션 없이 데이터 정합성 관리 가능
- MSA 환경에서 신뢰성 높은 트랜잭션 구현

---

### 3.3 Outbox 패턴
- DB 트랜잭션 안에서 이벤트를 **Outbox 테이블**에 저장
- 커밋 완료 후 외부 메시지 큐(Kafka, RabbitMQ)로 전송 또는 스케줄러 활용
- 이벤트 유실 방지

**예시**
```text
Order DB 트랜잭션 커밋
→ Outbox 테이블에 OrderCreatedEvent 저장
→ Outbox Processor가 이벤트 발행
→ Product, Coupon 서비스 처리
```

--- 

### 3.4 최종 설계
```text
핵심 도메인 로직은 각 DB 트랜잭션 내에서 처리.
도메인 간 연계 로직은 이벤트 기반 Saga 패턴으로 처리하고
장애 시 보상 트랜잭션을 설계한다. (예: 결제 취소 -> 재고 복구)
단, 중요 이벤트는 Outbox 패턴 활용하여 메시지 유실 방지한다.
```
---
## 4. 결론
```text
단일 DB 트랜잭션 기반 접근은 MSA 환경에서 한계가 존재한다.
따라서, 분산 트랜잭션 대신 이벤트 기반 처리 + Saga + Outbox 패턴 조합으로 데이터 정합성을 확보한다.
단, 이때 트랜잭션 처리 설계 시 서비스 경계, 이벤트 순서, 보상 트랜잭션 등을 반드시 고려해야 한다.
```


# 동시성 문제가 발생할 수 있는 기능

- 쿠폰발급
  - 많은 사용자가 동시에 요청을 보내는 경우
- 주문
  - 여러 사용자가 동시에 요청을 보내는 경우 상품 재고 
- 유저 잔액
  - 유저가 잔액 충전 또는 사용을 동시에 여러번 요청할 경우 

---

## 쿠폰발급 기능
### 문제 식별
>생성된 쿠폰보다 많은 사용자가 동시에 쿠폰발급을 받는 경우
> 
> 동시성 제어가 제대로 되지 않는 경우 race condition이 발생하여 발급된 쿠폰 수보다 많은 양의 쿠폰이 발급된다.
> 
> ex) 쿠폰 100장이 생성되었는데 150명의 사용자가 쿠폰을 발급받는 경우

### 분석
> 쿠폰 잔여 수량의 경우, 동시성 문제가 빈번하게 발생(충돌이 잦으며) 무결성 보장이 필요하다.
>
> 이러한 문제를 사전에 방지하기 위해 락 전략은 필수적이며,
>
> 충돌이 잦고, 무결성이 보장되어야 하므로 비관적 락을 통해 제어한다.

### 해결
> 업데이트 하고자 하는 row에 비관적 락을 통해 동시성을 제어.
> 
> JpaRepository에서 기본적으로 제공하는 find 메서드에는 @Lock 설정이 불가능하므로,
> 
> 비관적 락을 설정한 커스텀 find 메서드를 하나 만든다.

---

## 주문 - 재고차감 기능
### 문제 식별
> 동시에 재고보다 많은 주문이 들어올 경우 
>
> 동시성 제어가 제대로 되지 않는 경우 race condition이 발생하여 재고보다 많은 주문이 처리된다.
>
> ex) 재고는 100개인데 150개의 주문이 처리됨.

### 분석
> 상품 재고의 경우도 충돌이 잦으며 무결성 보장이 필요하다.
> 
> 따라서 비관적 락을 통해 동시성을 제어한다.

### 해결
> 주문은 동시성 문제가 빈번하게 발생하는 기능. (주문 프로세스 내에 재고차감이 포함되어있다.)
>
> 이러한 문제를 사전에 방지하기 위해 락 전략은 필수적이며,
>
> 충돌이 잦고, 무결성이 보장되어야 하므로 비관적 락을 통해 제어한다.
> 
> 마찬가지로, 락 설정을 위한 커스텀 find 메서드를 구상한다.

---

## 유저 잔액
### 문제 식별
> 유저가 잔액을 동시에 여러번 충전 또는 사용 요청을 보낼 경우
>
> 동시성 제어가 되지 않는 경우 실제 결과보다 적게 충전 또는 사용될 수 있다.
>
> ex) 10000원 충전을 동시에 100번 요청하였는데 실제 충전된 금액은 90만원.

### 분석
> 충전/사용의 경우 동시에 요청한다 하더라도, 사용자가 요청한 횟수만큼 충전/사용이 되어야한다.
>
> 다만, 잔액의 경우 한 사용자에 대해 1:1로 매칭되어있어 충돌이 잦지 않을 것으로 예상되므로 요구사항에 따라 비관적 락 또는 낙관적 락을 선택한다.
> 
> 여기서는, 요청을 모두 성공시켜야하므로 비관적 락을 통해 제어한다.

### 해결
> 잔액을 update하기 전 select할때 Lock을 걸어 제어를 한다.
> 
> 여기도 마찬가지로, 커스텀 find 메서드를 만든다.
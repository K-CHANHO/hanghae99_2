# 동시성 문제 보고서

---

## 1. 동시성 문제란?
> 여러 요청이 동시에 발생한 경우, 동시에 같은 자원에 접근하거나 조작하면서 데이터 불일치, 데이터 손실이 발생하는 현상.

## 2. 동시성 문제의 유형
`Race Condition` : 둘 이상의 스레드가 공유 자원에 동시에 접근하여 예상치 못한 결과를 초래하는 것  
`Dead Lock` : 두 개 이상의 작업이 서로가 가진 자원을 얻기 위해 무한정 대기하는 상태.  
`Live Lock` : 데드락을 해결하기 위해 서로 양보하다가 아무런 작업도 진행하지 못하는 상태.  
`Starvation` : 특정 스레드가 자원을 할당받지 못해 무한정 대기하는 상태.

## 3. 동시성 문제를 해결하는 방법
synchronized, ReentrantLock 등을 쓰레드의 접근을 제어하여 동시성을 해결하는 방법이 있으며  
DB를 활용하여 낙관적인 락, 비관적인 락을 이용하여 동시성을 해결하는 방법이 있다.  
=> 여기서는 DB를 활용하여 동시성을 제어

- DB를 활용한 동시성 제어 방법
 
|구분| 낙관적 락                                 | 비관적 락                                            |
|---|---------------------------------------|--------------------------------------------------|
|사용시기| 충돌이 많지 않은 경우                          | 충돌이 잦은 경우                                        |
|동작방식| 데이터를 저장할 때 충돌 검사                      | 데이터를 읽을때 락 걸기                                    |
|비고| 버전관리를 통해 충돌 여부 확인. <br/>충돌이 날 경우 재시도 전략 고려 | 데드락 예방을 위해 트랜잭션 순서 고려<br/>락으로 인해 성능 저하를 초래할 수 있음 |


## 4. 동시성 문제가 발생할 수 있는 기능

- 쿠폰발급
  - 많은 사용자가 동시에 요청을 보내는 경우
- 주문
  - 여러 사용자가 동시에 요청을 보내는 경우 상품 재고 
- 유저 잔액
  - 유저가 잔액 충전 또는 사용을 동시에 여러번 요청할 경우 

---

### 4-1) 쿠폰발급 기능
#### 문제 식별
>생성된 쿠폰보다 많은 사용자가 동시에 쿠폰발급을 받는 경우
> 
> 동시성 제어가 제대로 되지 않는 경우 race condition이 발생하여 발급된 쿠폰 수보다 많은 양의 쿠폰이 발급된다.
> 
> ex) 쿠폰 100장이 생성되었는데 150명의 사용자가 쿠폰을 발급받는 경우

#### 분석
> 쿠폰 잔여 수량의 경우, 동시성 문제가 빈번하게 발생(충돌이 잦으며) 무결성 보장이 필요하다.
>
> 이러한 문제를 사전에 방지하기 위해 락 전략은 필수적이며,
>
> 쿠폰 재고 테이블이라는 공유 자원이 여러 사용자에게 동시에 접근되므로, 락을 걸고 배타적인 접근을 보장하는 것이 중요하다.

#### 해결
> 업데이트 하고자 하는 row에 비관적 락을 통해 동시성을 제어.
> 
> JpaRepository에서 기본적으로 제공하는 find 메서드에는 @Lock 설정이 불가능하므로,
> 
> 비관적 락을 설정한 커스텀 find 메서드를 하나 만든다.

---

### 주문 - 재고차감 기능
#### 문제 식별
> 동시에 재고보다 많은 주문이 들어올 경우 
>
> 동시성 제어가 제대로 되지 않는 경우 race condition이 발생하여 재고보다 많은 주문이 처리된다.
>
> ex) 재고는 100개인데 150개의 주문이 처리됨.

#### 분석
> 상품 재고의 경우도 충돌이 잦으며 무결성 보장이 필요하다.
> 
> 특히, 재고가 0인 상태에서는 추가 주문을 막아야 하기 때문에 무결성이 더욱 강조된다.
> 
> 따라서 비관적 락을 통해 동시성을 제어한다.

#### 해결
> 주문은 동시성 문제가 빈번하게 발생하는 기능. (주문 프로세스 내에 재고차감이 포함되어있다.)
>
> 이러한 문제를 사전에 방지하기 위해 락 전략은 필수적이며,
>
> 충돌이 잦고, 무결성이 보장되어야 하므로 비관적 락을 통해 제어한다.
> 
> 마찬가지로, 락 설정을 위한 커스텀 find 메서드를 구상한다.

---

### 유저 잔액
#### 문제 식별
> 유저가 잔액을 동시에 여러번 충전 또는 사용 요청을 보낼 경우
>
> 동시성 제어가 되지 않는 경우 실제 결과보다 적게 충전 또는 사용될 수 있다.
>
> ex) 10000원 충전을 동시에 100번 요청하였는데 실제 충전된 금액은 90만원.

#### 분석
> 충전/사용의 경우 동시에 요청한다 하더라도, 사용자가 요청한 횟수만큼 충전/사용이 되어야한다.
>
> 다만, 잔액의 경우 한 사용자에 대해 1:1로 매칭되어있어 충돌이 잦지 않을 것으로 예상되므로 요구사항에 따라 비관적 락 또는 낙관적 락을 선택한다.
> 
> 여기서는, 잔액 충선/사용 시 동시성 문제가 발생할 가능성이 1% 미만인 것으로 가정하고, 낙관적 락으로 해결한다.

#### 해결
> JpaEntity에 @Version을 추가하여 버전관리를 한다.
> 
> 충돌이 날 경우 최대 3번 재시도를 하고 (@Retryable)
> 
> 실패할 경우 잔액 충전/사용은 되지 않고 에러를 뱉는다. 
>
> (이 때 발생하는 에러는 OptimisticLockingFailureException 에러이다.)

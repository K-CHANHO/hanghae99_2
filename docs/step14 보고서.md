# Redis를 활용한 쿠폰 발급 시스템 보고서

---

# 1. 개요 및 요구사항 분석
## 1-1. 배경
>기존 쿠폰 발급 시스템은 선착순 쿠폰 이벤트 시, 발급 요청이 한꺼번에 몰리면서 DB에 과부하가 발생하는 문제가 있었습니다.  
이로 인해 시스템 안정성이 저하되고, 사용자 경험에 부정적인 영향을 미칠 수 있습니다.

## 1-2. 요구사항
>이러한 문제점을 해결하기 위해 `레디스(Redis)`를 활용하여 선착순 쿠폰 발급 기능을 재설계하고, 안정적인 쿠폰 발급 로직을 구현하고자 합니다.  

주요 요구사항은 다음과 같습니다.

- 레디스 기반의 선착순 쿠폰 발급 시스템 설계
: 레디스의 특성과 다양한 자료구조를 활용하여 빠른 처리를 보장합니다.

- 비동기 시스템 설계
: 쿠폰 발급을 비동기적으로 처리하여 서버 부하를 분산시킵니다.

---

# 2. 레디스 기반 시스템 설계 및 구현
## 2-1. 데이터 모델
레디스의 `String`과 `Set` 자료구조를 활용하여 쿠폰 발급 로직을 설계했습니다.

`쿠폰 재고`

coupon:stock:{couponId} 와 같은 키 형식으로 관리하며,  
DECREMENT 명령어를 통해 재고를 원자적으로 감소시킵니다.


`쿠폰 발급자 목록`

쿠폰을 발급받은 사용자들의 ID를 SET에 저장하여 중복 발급을 방지합니다.

coupon:issue:{couponId}:userSet 와 같은 키 형식으로 관리하며, SADD 명령어를 통해 사용자 ID를 추가하고, 그 반환 값으로 중복 여부를 확인합니다.


## 2-2. 쿠폰 발급 로직 

`분산 락 적용` (동일)

>이 락은 특정 쿠폰에 대해서만 획득되므로, 서로 다른 쿠폰에 대한 발급 요청은 병렬로 처리될 수 있습니다.
>
>동일한 쿠폰에 대한 여러 발급 요청이 동시에 들어와도, 락을 통해 하나의 스레드만 접근하도록 제어하여 Race Condition을 근본적으로 방지하고, 쿠폰 재고 감소와 중복 발급 확인 로직의 `원자성을 보장`합니다.

`중복 발급 확인 (Set)` (개선)

> 쿠폰 아이디 및 유저 아이디를 기반으로 쿠폰 발급 기록을 Set에 추가합니다.
>
> Redis Set의 add 메서드는 새로운 요소를 추가했을 때 `1`, 이미 존재하는 요소일 경우 `0` 을 반환합니다.
>
>이 반환 값을 통해 사용자의 중복 발급 여부를 즉시 판단할 수 있으며, `0`을 반환받으면 이미 발급받은 사용자이므로 예외를 발생시켜 더 이상 진행하지 않습니다.

`쿠폰 재고 차감 (String)` (개선)

> decrement를 통해 해당 쿠폰의 재고를 1만큼 원자적으로 감소시킵니다.
>
> 감소 후 재고가 0 미만이 되면 쿠폰이 소진된 것으로 간주합니다.
> 이때, increment로 재고를 다시 0으로 원복시키고, 또한 Set에 추가했던 사용자 정보도 롤백한 후, 예외를 발생시킵니다.

`DB 저장 비동기 처리` (개선)

> @Async 어노테이션을 사용하여 쿠폰 발급 성공 후 데이터베이스에 UserCoupon 정보를 저장하는 로직을 비동기적으로 분리했습니다.
>
> 이로 인해 메인 스레드는 쿠폰 발급 요청에 대한 응답을 빠르게 반환할 수 있으며, DB 저장 작업은 별도의 스레드에서 처리됩니다.
>
> 이 방식은 메인 스레드의 부하를 줄이고, 사용자 경험을 향상시키는 데 기여합니다.


# 3. 회고
## 3-1. 개선점 및 성과
`높은 동시성 제어`
> Set을 이용한 중복 발급 체크와 분산락을 통해 데이터 정합성을 완벽하게 보장했습니다. 특히 쿠폰 ID 단위의 락은 불필요한 전체 락을 피하면서 효율적인 동시성 제어를 가능하게 했습니다.

`서버 부하 분산`
> @Async를 활용하여 DB 저장 로직을 비동기 처리함으로써, 초당 처리 가능한 요청 수가 크게 증가했습니다. 이는 실제 서비스 환경에서 사용자의 대기 시간을 줄이는 데 기여합니다.

`직관적인 로직`
> 분산 락, 재고 감소, 중복 체크 로직이 메서드 내에서 명확하게 분리되어 있어 코드의 가독성과 유지보수성이 높아졌습니다.

## 3-2. 보완점
`분산 락의 성능 오버헤드`
> 락을 획득하고 해제하는 과정에서 성능 오버헤드가 발생할 수 있습니다. 
> 
> 보완방법으로는 중복 확인, 재고 차감, 롤백 등 여러 Redis 명령어를 `Lua Script`를 활용하여 하나의 원자적인 스크립트로 묶어 실행하면 네트워크 지연을 최소화하는 방법이 있습니다.

`비동기 작업 실패 처리`
> @Async 메서드 내에서 예외가 발생할 경우, 호출한 메인 스레드로 직접 전파되지 않아 작업 실패를 인지하기 어렵습니다. 이를 보완하기 위해 비동기 작업의 실패를 로그로 상세히 기록하거나, 별도의 실패 처리 메커니즘을 도입하여 데이터 일관성을 유지하고 장애에 대비해야 합니다.

`Redis 서버 장애`
> 단일 Redis 서버일 경우, Redis 서버 장애가 발생하면 분산 락과 재고 관리가 불가능해져 시스템 전체에 영향이 갈 수 있습니다. 
> 
> 보완방법으로는 `Redis Sentinel` 또는 `Redis Cluster` 구성을 통해 고가용성을 확보하여 장애 시에도 서비스가 중단 없이 지속될 수 있도록 해야 합니다.

`완벽한 선착순 발급 보장`
> 현재는 분산락으로 인해 중복 발급은 방지되지만, 선착순 발급이 완벽하게 보장되지는 않습니다.
>
> 왜냐하면 분산락은 순서를 보장하지 않기 때문에, 여러 요청이 동시에 들어올 경우 선착순이 아닌 임의의 순서로 발급될 수 있습니다.
>
> 보완방법으로는 Sorted Set + Worker(스케줄러) 구성을 통해 요청 순서를 보장하는 방법이 있지만, @Scheduled의 경우 쿠폰발급이 없는 경우에도 주기적으로 실행되어 불필요한 자원이 낭비될 수 있습니다.
> 
> 따라서 추후에 RabbitMQ, kafka 등 메시지 큐를 도입하여 요청 순서를 보장하는 방법을 고려할 수 있습니다.

## 3-3. 결론
>레디스의 다양한 자료구조와 기능을 활용하여 선착순 쿠폰 발급 시스템을 효과적으로 개선하였습니다.  
또한, 비동기 처리의 결합은 대규모 트래픽을 처리하는 서비스에서 매우 유용한 접근 방식이며,  
향후에는 Redis Sentinel/Cluster 도입, 비동기 작업의 실패 처리 로직 보강, 메시지 큐 도입 등을 통해 더욱 견고하고 안정적인 서비스를 만들어나갈 계획입니다.
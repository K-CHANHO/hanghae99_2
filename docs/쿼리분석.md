# 쿼리 분석 보고서

---

## user_coupon 테이블
* 데이터 약 80만건


| 컬럼명   | 타입    | 비고    |
|-------|-------|-------|
|coupon_id|bigint|쿠폰ID|
|user_id|varchar(20)|유저ID|
|status|varchar(10)|AVAILABLE, USED, EXPIRED|
|issued_at|datetime|쿠폰 발급 시간|
|expired_at|datetime|쿠폰 만료 시간|
|used_at|datetime|쿠폰 사용 시간|



### 테스트 쿼리 1

```sql 
SELECT user_coupon_id, coupon_id, expired_at, issued_at, status, used_at, user_id 
FROM user_coupon 
WHERE user_id='sampleUserId' 
AND coupon_id=100;
```
`최적화 전`
> `type` : ALL
> 
>`key` : NULL
> 
> `rows` : 782912
> 
> `실행속도` : 152 ms
> 
>- 인덱스가 설정되어있지 않아 풀스캔을 하고 있음.

`최적화 방안`
> - `UserCoupon` 테이블은 `user_id` 와 `coupon_id` 를 조건으로 조회하는 쿼리가 자주 발생할 것으로 예상됨.
> 
> - 따라서 복합인덱스를 설정하되, 카디널리티가 높은 순으로 인덱스를 설정해야함.
> 
> - `user_id`는 고유한 값이므로 카디널리티가 매우 높음.
> 
> - 따라서 (`user_id`, `coupon_id`) 순으로 복합 인덱스를 설정.

`인덱스 설정`
> CREATE INDEX idx_user_coupon_user_id_coupon_id
ON user_coupon(user_id, coupon_id);

`최적화 후`
> `type` : ref
> 
> `key` : idx_user_coupon_user_id_coupon_id
> 
> `rows` : 1
> 
> `실행속도` : 0.78 ms

`결과`
>실행속도가 152 ms -> 0.78 ms 로 월등히 향상되었음.
---

### 테스트 쿼리 2

```sql 
SELECT count(user_coupon_id) 
FROM user_coupon 
WHERE coupon_id=100;
```

`최적화 전`
> `type` : ALL
> 
> `key` : NULL
> 
> `rows` : 782912
> 
> `실행속도` : 96 ms
> 
> 인덱스가 설정되어있지 않아 풀스캔을 하고 있음.

`최적화 방안`
> 1. 위에서 생성한 idx_user_coupon_userid_coupon_id 인덱스 사용
> 2. 조건으로 사용되는 coupon_id를 단일 인덱스로 설정

`인덱스 설정`
> CREATE INDEX idx_user_coupon_coupon_id ON user_coupon(coupon_id);

`최적화 후`
>
> 1번 방안
>
> `type` : range
>
> `key` : idx_user_coupon_userid_coupon_id
>
> `rows` : 78291
>
> `실행속도` : 0.90 ms
> 
> \
> 2번 방안
> 
> `type` : ref
>
> `key` : idx_user_coupon_coupon_id
>
> `rows` : 1
> 
> `실행속도` : 0.75 ms

`결과`
> coupon_id 를 단일 인덱스로 설정한 경우가 조금 더 빠르긴 하나 큰 차이가 없고
> 
> 해당 테이블은 SELECT 뿐만 아니라 INSERT, UPDATE도 자주 발생하기 때문에 인덱스를 많이 둘 수록 불리할 수 있다.
> 
> 따라서, 1번 방안으로 선택.
> 
> 96 ms -> 0.90 ms 로 속도가 크게 향상되었다.

---

## payment 테이블
* 데이터 약 260만건


| 컬럼명        | 타입          | 비고            |
|------------|-------------|---------------|
| payment_id | bigint      | 결제ID          |
| user_id    | varchar(20) | 유저ID          |
| order_id   | bigint      | 주문ID          |
| paid_price | int         | 결제금액          |
| paid_at    | datetime    | 결제 시간         |
| status     | varchar(10) | PENDING, PAID |

### 테스트 쿼리

```sql
SELECT payment_id, order_id, paid_at, paid_price, status, user_id 
FROM payment 
WHERE status='PAID'
AND paid_at > '2025-07-30 00:50:00';
```
`최적화 전`
> `type` : ALL 
> 
> `key` : NULL
> 
> `rows` : 2610074
> 
> `실행속도` : 442 ms
> 
> 인덱스가 설정되어있지 않아 풀스캔을 하고 있음.

`최적화 방안`
> 조건으로 사용되는 paid_at, status를 복합인덱스로 설정
> 
> paid_at 컬럼이 datetime 타입으로 거의 고유한 값을 가질 것이기에 카디널리티가 높다.
> 
> 하지만, 보통 paid_at 보다는 status를 조건으로 하는 쿼리문이 더 많을 것으로 판단되므로 status를 우선하여 인덱스를 설정한다.

`인덱스 설정`
> CREATE INDEX idx_payment_status_paid_at ON payment(status, paid_at);


`최적화 후`
> `type` : RANGE
>
> `key` : idx_payment_status_paid_at
>
> `rows` : 1
>
> `실행속도` : 0.44 ms

`결과`
> 조회속도가 442 ms -> 0.44 ms 로 크게 향상되었다.


---

## order_product 테이블
* 데이터 약 190만건

| 컬럼명              | 타입     | 비고       |
|------------------|--------|----------|
| order_product_id | bigint | 주문상품ID   |
| order_id         | bigint | 주문ID     |
| product_id       | bigint | 상품ID     |
| price            | int    | 주문 상품 가격 |
| quantity         | int    | 주문 수량    |

### 테스트 쿼리

```sql 
SELECT product_id 
FROM order_product 
WHERE order_id IN (1,2,3,4,5) 
GROUP BY product_id 
ORDER BY count(product_id) DESC LIMIT 5;
```
`최적화 전`
> `type` : ALL
> 
> `key` : NULL
> 
> `rows` : 1894536
> 
> `실행속도` : 330 ms
> 
>인덱스가 설정되어있지 않아 풀스캔을 하고 있음

`최적화 방안`
> 조건절에 사용되는 order_id로 1차적으로 필터링 한 뒤
> 
> product_id로 집계하면, 인덱스만으로 결과 추출이 가능할 것으로 보임.
> 
> 따라서, 복합인덱스 (order_id, product_id)를 설정.

`인덱스 설정`
> CREATE INDEX idx_order_product_order_id_product_id ON order_product(order_id, product_id);

`최적화 후`
> `type` : INDEX
>
> `key` : idx_order_product_order_id_product_id
>
> `extra` : Using where; Using index; Using temporary; Using filesort
> 
> `rows` : 1894536
>
> `실행속도` : 295 ms

`결과`
> 인덱스 추가 전/후 크게 차이 없음.
> 
> 조건 및 그룹핑에는 인덱스를 활용하지만, 정렬을 할 떄는 인덱스가 활용될 수 없다.
> 
> 인덱스만으로는 해결할 수 없고 파티셔닝 등을 고려해야 한다.